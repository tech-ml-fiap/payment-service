name: CI/CD Payment Service

on:
  push:
    branches: [main, master]

env:
  AWS_REGION: us-east-1
  ECR_REPO:  payment-service

  # VariÃ¡veis sensÃ­veis (GitHub â†’ Settings â†’ Secrets â†’ Actions)
  DB_HOST:   ${{ secrets.DB_HOST }}
  DB_PORT:   ${{ secrets.DB_PORT }}
  DB_USER:   ${{ secrets.DB_USER }}
  DB_PASS:   ${{ secrets.DB_PASSWORD }}
  DB_NAME:   ${{ secrets.DB_NAME }}
  SECRET_KEY: ${{ secrets.SECRET_KEY }}
  ALGORITHM:  ${{ secrets.ALGORITHM }}
  ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    # 1) Checkout
    - uses: actions/checkout@v4

    # 2) Credenciais AWS
    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region:            ${{ env.AWS_REGION }}

    # 3) Login ECR
    - uses: aws-actions/amazon-ecr-login@v2

    # 4) Build & push da imagem
    - name: Build & Push image
      id: build
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPO 2>/dev/null \
          || aws ecr create-repository --repository-name $ECR_REPO --image-tag-mutability MUTABLE

        IMAGE_URI=$(aws ecr describe-repositories --repository-names $ECR_REPO \
                    --query 'repositories[0].repositoryUri' --output text)

        docker build -t $IMAGE_URI:${{ github.sha }} .
        docker push     $IMAGE_URI:${{ github.sha }}

        echo "IMAGE_URI=$IMAGE_URI:${{ github.sha }}" >> $GITHUB_ENV
        echo "APP_VERSION=${{ github.sha }}"        >> $GITHUB_ENV

    # 5) Gera Dockerrun e zipa
    - name: Generate Dockerrun & ZIP
      run: |
        cat > Dockerrun.aws.json <<EOF
        {
          "AWSEBDockerrunVersion": "1",
          "Image": { "Name": "${IMAGE_URI}", "Update": "true" },
          "Ports": [ { "ContainerPort": "8000" } ]
        }
        EOF
        zip -q deploy.zip Dockerrun.aws.json
        echo "ZIP_PATH=$(pwd)/deploy.zip" >> $GITHUB_ENV

    # 6) Terraform Init
    - uses: hashicorp/setup-terraform@v3
      with: { terraform_version: 1.6.5 }

    - name: Terraform Init
      working-directory: infra
      run: terraform init -input=false

    # 7) Importa app + bucket, se jÃ¡ existirem (idempotente)
    - name: Importar recursos se jÃ¡ existirem
      working-directory: infra
      shell: bash
      run: |
        set -euo pipefail
        set -x

        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        BUCKET="payment-service-artifacts-${ACCOUNT_ID}"

        # ---- FunÃ§Ã£o de import idempotente ----
        import() {
          terraform import \
            -var="app_version=${APP_VERSION}" \
            -var="artifact_zip=${ZIP_PATH}" \
            -var="db_host=${DB_HOST}" \
            -var="db_port=${DB_PORT}" \
            -var="db_user=${DB_USER}" \
            -var="db_password=${DB_PASS}" \
            -var="db_name=${DB_NAME}" \
            -var="secret_key=${SECRET_KEY}" \
            -var="algorithm=${ALGORITHM}" \
            -var="token_expire=${ACCESS_TOKEN_EXPIRE_MINUTES}" \
            "$@"
        }

        # Evita erro se o state ainda nÃ£o existe
        terraform state list >/dev/null 2>&1 || true

        # ---------- AplicaÃ§Ã£o EB ----------
        aws elasticbeanstalk describe-applications \
          --application-names payment-service --query 'Applications[0]' --output text >/dev/null 2>&1 &&
          ! terraform state list | grep -q '^aws_elastic_beanstalk_application\.app$' &&
          import aws_elastic_beanstalk_application.app payment-service || true

        # ---------- Bucket ----------
        aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null &&
          ! terraform state list | grep -q '^aws_s3_bucket\.artifacts$' &&
          import aws_s3_bucket.artifacts "$BUCKET" || true  

      # 8) Terraform Apply
    - name: Terraform Apply
      working-directory: infra
      run: |
        terraform apply -auto-approve -input=false \
          -var="app_version=${APP_VERSION}" \
          -var="artifact_zip=${ZIP_PATH}" \
          -var="db_host=${DB_HOST}" \
          -var="db_port=${DB_PORT}" \
          -var="db_user=${DB_USER}" \
          -var="db_password=${DB_PASS}" \
          -var="db_name=${DB_NAME}" \
          -var="secret_key=${SECRET_KEY}" \
          -var="algorithm=${ALGORITHM}" \
          -var="token_expire=${ACCESS_TOKEN_EXPIRE_MINUTES}"

    # 9) Exibe a URL pÃºblica
    - name: Show service URL
      working-directory: infra
      run: echo "ðŸŸ¢ URL -> $(terraform output -raw service_url)"
